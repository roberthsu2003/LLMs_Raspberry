# 練習：從前景程序到背景工作

**目標：** 透過親手操作，體驗程序在前、後景切換的完整生命週期。

---

### 1️⃣ 體驗前景程序

1.  在終端機輸入 `sleep 300` 並按下 Enter。
2.  **思考與觀察：**
    *   你的終端機現在是什麼狀態？還能輸入其他指令嗎？
    *   這就是「前景程序」，它會佔用你的終端機直到執行完畢。
3.  按下 `Ctrl + C`。
4.  **思考與觀察：**
    *   發生了什麼事？`sleep` 程序還在嗎？
    *   你如何確認 `sleep` 已經不在執行了？(提示: `ps`)

---

### 2️⃣ 將程序送到背景

1.  這次，請輸入 `sleep 300 &` 並按下 Enter。
2.  **觀察與記錄：**
    *   畫面上出現了什麼？ (`[1] 12345` 的格式)
    *   記下你的「工作編號 (Job ID)」和「程序編號 (PID)」。
    *   終端機現在可以輸入指令了嗎？
3.  執行 `ps aux | grep sleep`，確認 `sleep` 程序仍在背景執行。

---

### 3️⃣ 背景工作控制

現在我們有一個在背景執行的工作，讓我們來操作它。

1.  執行 `jobs -l`。
    *   **問題：** 這個指令告訴了你什麼？它顯示的資訊跟上一步記錄的一樣嗎？
2.  執行 `fg %1` (如果你的工作編號不是 1，請替換它)。
    *   **觀察：** 終端機發生了什麼變化？`sleep` 程序現在在哪裡？
3.  這次，不要按 `Ctrl + C`，改為按下 `Ctrl + Z`。
    *   **觀察與記錄：** 畫面上顯示了什麼狀態 (e.g., Stopped)？
    *   執行 `jobs -l`，看看 `sleep` 現在的狀態是什麼。
4.  執行 `bg %1`。
    *   **觀察：** `sleep` 的狀態又變成了什麼？
5.  最後，使用 `kill %1` 來終止這個工作。
    *   執行 `jobs -l` 確認它已被 `Terminated` (終止)。
    *   執行 `ps aux | grep sleep` 確認它已從程序列表中消失。

---

### 4️⃣ 挑戰：關閉終端機

這個練習將讓你深刻體會 `nohup` 的重要性。**你需要開啟兩個終端機視窗來完成。**

**實驗 A：不使用 nohup**

1.  在 **終端機 A** 中，執行 `sleep 300 &`。
2.  執行 `jobs` 確認它在背景執行。
3.  現在，直接關閉 **終端機 A** 的視窗。
4.  在 **終端機 B** 中，執行 `ps aux | grep sleep`。
    *   **問題：** 你還能找到 `sleep` 程序嗎？它去哪了？

**實驗 B：使用 nohup**

1.  重新打開一個 **終端機 A**，這次執行 `nohup sleep 300 &`。
2.  你會看到一個關於 `nohup.out` 的訊息。
3.  現在，再次關閉 **終端機 A** 的視窗。
4.  在 **終端機 B** 中，執行 `ps aux | grep sleep`。
    *   **問題：** 這次 `sleep` 程序是否還在？
    *   **進階問題：** `nohup` 和 `systemd` 服務有什麼本質上的不同？為什麼正式環境不能只用 `nohup`？

---

### 5️⃣ 觀念問答

1.  當你按下 `Ctrl + C` 時，系統送出了什麼信號？
2.  當你按下 `Ctrl + Z` 時，系統送出了什麼信號？
3.  當你關閉終端機時，系統預設會送出什麼信號？`nohup` 的作用是什麼？
4.  請用你自己的話，簡單描述「前景程序」、「背景工作」和「系統服務」三者最大的區別。

---

## 作業提交說明

請將以上每個步驟的指令、輸出、以及「問題」的答案整理成一份文件提交。